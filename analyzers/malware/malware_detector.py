"""
Malware Traffic Analyzer
- DGA detection via domain entropy and NXDOMAIN ratio
- Lateral movement heuristics (SMB 445, RDP 3389)
- C2 beacon/backdoor heuristics (regular intervals, small packets)
- Basic ransomware activity heuristics (SMB spikes, mass connections)
"""

from typing import Dict, List, Any, Optional, Tuple
from collections import defaultdict
from scapy.all import IP, IPv6, TCP, UDP, DNS, DNSQR, DNSRR
import math
import statistics
import re


def _is_private_ipv4(ip: str) -> bool:
    try:
        octets = [int(x) for x in ip.split('.')]
        if len(octets) != 4:
            return False
        if octets[0] == 10:
            return True
        if octets[0] == 172 and 16 <= octets[1] <= 31:
            return True
        if octets[0] == 192 and octets[1] == 168:
            return True
        return False
    except:
        return False


def _entropy(s: str) -> float:
    if not s:
        return 0.0
    freq = defaultdict(int)
    for ch in s:
        freq[ch] += 1
    n = len(s)
    ent = 0.0
    for c in freq.values():
        p = c / n
        ent -= p * math.log2(p)
    return ent


def _base_domain(name: str) -> str:
    parts = name.strip('.').lower().split('.')
    if len(parts) >= 2:
        return '.'.join(parts[-2:])
    return name.lower()


class MalwareAnalyzer:
    SMB_PORTS = {445, 139}
    RDP_PORTS = {3389}
    C2_PORT_HINTS = {80, 443, 8080, 8443, 53}

    def __init__(self):
        self.dns_queries = []  # (time, src_ip, qname, rcode, answers)
        self.flow_times = defaultdict(list)  # key -> timestamps
        self.flow_sizes = defaultdict(list)  # key -> packet sizes
        self.lateral_contacts = defaultdict(set)  # src -> set(dst)
        self.smb_sessions = defaultdict(int)  # src -> count
        self.rdp_sessions = defaultdict(int)  # src -> count

    def _flow_key(self, pkt) -> Optional[Tuple[str, int, str, int, str]]:
        if pkt.haslayer(IP):
            ip = pkt[IP]
            proto = 'TCP' if pkt.haslayer(TCP) else 'UDP' if pkt.haslayer(UDP) else str(ip.proto)
            sport = pkt[TCP].sport if pkt.haslayer(TCP) else (pkt[UDP].sport if pkt.haslayer(UDP) else 0)
            dport = pkt[TCP].dport if pkt.haslayer(TCP) else (pkt[UDP].dport if pkt.haslayer(UDP) else 0)
            return (ip.src, sport, ip.dst, dport, proto)
        elif pkt.haslayer(IPv6):
            ip = pkt[IPv6]
            proto = 'TCP' if pkt.haslayer(TCP) else 'UDP' if pkt.haslayer(UDP) else str(ip.nh)
            sport = pkt[TCP].sport if pkt.haslayer(TCP) else (pkt[UDP].sport if pkt.haslayer(UDP) else 0)
            dport = pkt[TCP].dport if pkt.haslayer(TCP) else (pkt[UDP].dport if pkt.haslayer(UDP) else 0)
            return (ip.src, sport, ip.dst, dport, proto)
        return None

    def _track_dns(self, pkt):
        dns = pkt[DNS]
        qname = dns[DNSQR].qname.decode('utf-8', errors='ignore') if dns.qr == 0 and dns.qdcount > 0 else ''
        rcode = getattr(dns, 'rcode', 0)
        answers = []
        if dns.qr == 1 and dns.ancount > 0:
            for i in range(dns.ancount):
                try:
                    rr = dns.an[i]
                    if isinstance(rr, DNSRR):
                        answers.append(rr.rdata if isinstance(rr.rdata, str) else str(rr.rdata))
                except Exception:
                    pass
        t = float(getattr(pkt, 'time', 0.0))
        src_ip = pkt[IP].src if pkt.haslayer(IP) else (pkt[IPv6].src if pkt.haslayer(IPv6) else 'N/A')
        self.dns_queries.append((t, src_ip, qname, rcode, answers))

    def _track_lateral(self, pkt):
        if not pkt.haslayer(IP):
            return
        ip = pkt[IP]
        sport = pkt[TCP].sport if pkt.haslayer(TCP) else (pkt[UDP].sport if pkt.haslayer(UDP) else 0)
        dport = pkt[TCP].dport if pkt.haslayer(TCP) else (pkt[UDP].dport if pkt.haslayer(UDP) else 0)
        if dport in self.SMB_PORTS or dport in self.RDP_PORTS:
            if _is_private_ipv4(ip.dst):
                self.lateral_contacts[ip.src].add(ip.dst)
                if dport in self.SMB_PORTS:
                    self.smb_sessions[ip.src] += 1
                if dport in self.RDP_PORTS:
                    self.rdp_sessions[ip.src] += 1

    def analyze_packet(self, pkt):
        key = self._flow_key(pkt)
        if key:
            t = float(getattr(pkt, 'time', 0.0))
            size = len(pkt)
            self.flow_times[key].append(t)
            self.flow_sizes[key].append(size)

        if pkt.haslayer(DNS) and pkt.haslayer(DNSQR):
            self._track_dns(pkt)
        self._track_lateral(pkt)

    def _detect_dga(self) -> Dict[str, Any]:
        findings = {'suspicious_domains': [], 'nx_ratio_by_src': {}, 'high_entropy_count': 0}
        by_src = defaultdict(lambda: {'n': 0, 'nx': 0})
        for (_, src, qname, rcode, _ans) in self.dns_queries:
            if not qname:
                continue
            by_src[src]['n'] += 1
            if rcode == 3:
                by_src[src]['nx'] += 1
            # entropy on label (exclude TLD)
            label = qname.strip('.').split('.')[0]
            ent = _entropy(label)
            if ent >= 3.6 and len(label) >= 8:
                findings['suspicious_domains'].append({'domain': qname, 'entropy': round(ent, 2), 'src': src})
        findings['high_entropy_count'] = len(findings['suspicious_domains'])
        for src, d in by_src.items():
            if d['n']:
                findings['nx_ratio_by_src'][src] = round(d['nx'] / d['n'], 3)
        return findings

    def _detect_beacons(self) -> List[Dict[str, Any]]:
        beacons = []
        for key, times in self.flow_times.items():
            if len(times) < 6:
                continue
            times_sorted = sorted(times)
            intervals = [t2 - t1 for t1, t2 in zip(times_sorted, times_sorted[1:]) if t2 >= t1]
            if len(intervals) < 5:
                continue
            mean = statistics.mean(intervals)
            if mean <= 0:
                continue
            stdev = statistics.pstdev(intervals)
            cv = stdev / mean if mean else 0
            sizes = self.flow_sizes[key]
            size_cv = (statistics.pstdev(sizes) / statistics.mean(sizes)) if len(sizes) >= 2 and statistics.mean(sizes) else 1.0
            # Beacon if timing regular and small variation in sizes
            if cv < 0.25 and size_cv < 0.5 and mean > 1.0:
                beacons.append({'flow': key, 'median_interval_s': round(statistics.median(intervals), 3), 'interval_cv': round(cv, 3)})
        return beacons

    def _detect_lateral_movement(self) -> List[Dict[str, Any]]:
        alerts = []
        for src, dsts in self.lateral_contacts.items():
            if len(dsts) >= 10:
                alerts.append({'src': src, 'hosts_contacted': len(dsts), 'type': 'SMB/RDP sweep'})
        return alerts

    def _detect_ransomware(self) -> List[Dict[str, Any]]:
        alerts = []
        # Heuristic: spikes in SMB sessions from a single host
        for src, count in self.smb_sessions.items():
            if count >= 100:
                alerts.append({'src': src, 'smb_sessions': count, 'type': 'Possible ransomware encryption activity'})
        return alerts

    def analyze(self, packets: List) -> Dict[str, Any]:
        for pkt in packets:
            self.analyze_packet(pkt)

        dga = self._detect_dga()
        beacons = self._detect_beacons()
        lateral = self._detect_lateral_movement()
        ransomware = self._detect_ransomware()

        suspicious = []
        if dga['high_entropy_count'] > 20:
            suspicious.append({'type': 'DGA activity', 'severity': 'high', 'details': f"{dga['high_entropy_count']} high-entropy domains"})
        if any(alert for alert in lateral):
            max_hosts = max(a['hosts_contacted'] for a in lateral)
            suspicious.append({'type': 'Lateral movement', 'severity': 'high' if max_hosts > 50 else 'medium', 'details': f"max hosts contacted: {max_hosts}"})
        if any(alert for alert in ransomware):
            suspicious.append({'type': 'Ransomware-like SMB spikes', 'severity': 'high', 'details': f"hosts: {len(ransomware)}"})
        if len(beacons) > 0:
            suspicious.append({'type': 'C2 beaconing', 'severity': 'medium', 'details': f"flows: {len(beacons)}"})

        return {
            'dns': dga,
            'beacons': beacons,
            'lateral_movement': lateral,
            'ransomware_signals': ransomware,
            'suspicious_patterns': suspicious
        }


def detect_malware_traffic(packets: List) -> Dict[str, Any]:
    analyzer = MalwareAnalyzer()
    return analyzer.analyze(packets)
