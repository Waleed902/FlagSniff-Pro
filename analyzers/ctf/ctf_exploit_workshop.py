"""
Interactive Exploit Workshop for CTF Analysis
Provides vulnerability scanning, payload generation, and guided exploitation
"""

import re
import json
import base64
import urllib.parse
import hashlib
import random
import string
from typing import Dict, List, Any, Tuple, Optional
from datetime import datetime, timedelta
from collections import defaultdict

class ExploitWorkshop:
    """Interactive exploit development and vulnerability analysis for CTF"""
    
    def __init__(self, logger=None):
        self.logger = logger
        self.vulnerability_database = self._load_vulnerability_patterns()
        self.payload_templates = self._load_payload_templates()
        
    def analyze_vulnerabilities(self, packets: List[Any], packet_data_list: List[Dict]) -> Dict[str, Any]:
        """Comprehensive vulnerability analysis with exploit suggestions"""
        results = {
            'vulnerabilities': [],
            'exploitation_opportunities': [],
            'payload_suggestions': [],
            'attack_vectors': [],
            'context_analysis': {},
            'difficulty_assessment': {},
            'metadata': {
                'total_packets': len(packets),
                'analysis_timestamp': datetime.now().isoformat(),
                'scan_techniques': ['web_vulns', 'network_vulns', 'crypto_vulns']
            }
        }
        
        try:
            # Web application vulnerabilities
            web_vulns = self._scan_web_vulnerabilities(packet_data_list)
            results['vulnerabilities'].extend(web_vulns)
            
            # Network protocol vulnerabilities
            network_vulns = self._scan_network_vulnerabilities(packet_data_list)
            results['vulnerabilities'].extend(network_vulns)
            
            # Generate exploitation opportunities
            exploit_ops = self._generate_exploitation_opportunities(results['vulnerabilities'])
            results['exploitation_opportunities'] = exploit_ops
            
            # Create payload suggestions
            payload_suggestions = self._generate_payload_suggestions(results['vulnerabilities'])
            results['payload_suggestions'] = payload_suggestions
            
            # Context-aware analysis
            context_analysis = self._perform_context_analysis(packet_data_list, results['vulnerabilities'])
            results['context_analysis'] = context_analysis
            
            # Difficulty assessment
            difficulty = self._assess_challenge_difficulty(results)
            results['difficulty_assessment'] = difficulty
            
        except Exception as e:
            if self.logger:
                self.logger.error(f"Vulnerability analysis failed: {str(e)}")
            results['error'] = str(e)
            
        return results
    
    def _scan_web_vulnerabilities(self, packet_data_list: List[Dict]) -> List[Dict[str, Any]]:
        """Scan for web application vulnerabilities"""
        vulnerabilities = []
        
        try:
            for i, packet_data in enumerate(packet_data_list):
                data = packet_data.get('data', '')
                if not isinstance(data, str):
                    continue
                    
                # SQL Injection detection
                sql_vulns = self._detect_sql_injection(data, i)
                vulnerabilities.extend(sql_vulns)
                
                # XSS detection
                xss_vulns = self._detect_xss(data, i)
                vulnerabilities.extend(xss_vulns)
                
                # Command injection detection
                cmd_vulns = self._detect_command_injection(data, i)
                vulnerabilities.extend(cmd_vulns)
                
                # Authentication bypass detection
                auth_vulns = self._detect_auth_bypass(data, i)
                vulnerabilities.extend(auth_vulns)
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Web vulnerability scanning failed: {str(e)}")
                
        return vulnerabilities
    
    def _generate_exploitation_opportunities(self, vulnerabilities: List[Dict]) -> List[Dict[str, Any]]:
        """Generate exploitation opportunities based on discovered vulnerabilities"""
        opportunities = []
        
        try:
            # Group vulnerabilities by type
            vuln_groups = defaultdict(list)
            for vuln in vulnerabilities:
                vuln_groups[vuln['type']].append(vuln)
                
            # Generate exploitation chains
            for vuln_type, vulns in vuln_groups.items():
                if len(vulns) > 1:
                    opportunities.append({
                        'type': 'chained_exploitation',
                        'vulnerability_chain': [v['type'] for v in vulns],
                        'confidence': 85,
                        'description': f'Multiple {vuln_type} vulnerabilities can be chained',
                        'difficulty': 'Hard',
                        'estimated_time': '30-60 minutes',
                        'tools_required': self._suggest_exploitation_tools(vuln_type)
                    })
                    
            # Generate single exploitation opportunities
            for vuln in vulnerabilities:
                if vuln['confidence'] > 80:
                    opportunities.append({
                        'type': 'single_exploitation',
                        'vulnerability': vuln['type'],
                        'confidence': vuln['confidence'],
                        'description': f'High-confidence {vuln["type"]} exploitation opportunity',
                        'difficulty': vuln.get('exploitation_difficulty', 'Medium'),
                        'estimated_time': '10-30 minutes',
                        'tools_required': self._suggest_exploitation_tools(vuln['type'])
                    })
                    
        except Exception as e:
            if self.logger:
                self.logger.error(f"Exploitation opportunity generation failed: {str(e)}")
                
        return opportunities
    
    def _generate_payload_suggestions(self, vulnerabilities: List[Dict]) -> List[Dict[str, Any]]:
        """Generate context-specific payload suggestions"""
        suggestions = []
        
        try:
            for vuln in vulnerabilities:
                vuln_type = vuln['type']
                
                if vuln_type == 'sql_injection':
                    suggestions.extend(self._generate_sql_payloads())
                elif vuln_type == 'xss':
                    suggestions.extend(self._generate_xss_payloads())
                elif vuln_type == 'command_injection':
                    suggestions.extend(self._generate_command_payloads())
                elif vuln_type == 'auth_bypass':
                    suggestions.extend(self._generate_auth_bypass_payloads())
                    
        except Exception as e:
            if self.logger:
                self.logger.error(f"Payload generation failed: {str(e)}")
                
        return suggestions
    
    def _perform_context_analysis(self, packet_data_list: List[Dict], vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Perform context-aware analysis to adjust confidence scores"""
        context = {
            'challenge_type': 'unknown',
            'technology_stack': [],
            'security_measures': [],
            'confidence_adjustments': {},
            'environmental_factors': {}
        }
        
        try:
            # Detect challenge type based on traffic patterns
            context['challenge_type'] = self._detect_challenge_type(packet_data_list)
            
            # Identify technology stack
            context['technology_stack'] = self._identify_technology_stack(packet_data_list)
            
            # Detect security measures
            context['security_measures'] = self._detect_security_measures(packet_data_list)
            
            # Adjust confidence scores based on context
            context['confidence_adjustments'] = self._calculate_context_adjustments(
                vulnerabilities, context['challenge_type'], context['security_measures']
            )
            
        except Exception as e:
            if self.logger:
                self.logger.error(f"Context analysis failed: {str(e)}")
                
        return context
    
    def _assess_challenge_difficulty(self, analysis_results: Dict) -> Dict[str, Any]:
        """Assess the overall challenge difficulty"""
        difficulty = {
            'overall_rating': 'Medium',
            'factors': {},
            'score': 50,
            'recommendations': []
        }
        
        try:
            score = 50  # Base score
            factors = {}
            
            # Vulnerability complexity factor
            vuln_count = len(analysis_results.get('vulnerabilities', []))
            if vuln_count > 5:
                score += 20
                factors['high_vulnerability_count'] = +20
            elif vuln_count < 2:
                score -= 15
                factors['low_vulnerability_count'] = -15
                
            # Exploitation chain complexity
            chains = [opp for opp in analysis_results.get('exploitation_opportunities', []) 
                     if opp['type'] == 'chained_exploitation']
            if chains:
                score += 25
                factors['exploitation_chains'] = +25
                
            # Determine rating
            if score < 30:
                difficulty['overall_rating'] = 'Easy'
            elif score < 60:
                difficulty['overall_rating'] = 'Medium'
            elif score < 85:
                difficulty['overall_rating'] = 'Hard'
            else:
                difficulty['overall_rating'] = 'Expert'
                
            difficulty['score'] = min(100, max(0, score))
            difficulty['factors'] = factors
            
            # Generate recommendations
            if score > 70:
                difficulty['recommendations'].append('Focus on understanding the exploitation chain')
                difficulty['recommendations'].append('Consider automated tools for initial reconnaissance')
            else:
                difficulty['recommendations'].append('Start with basic vulnerability exploitation')
                difficulty['recommendations'].append('Manual analysis should be sufficient')
                
        except Exception as e:
            if self.logger:
                self.logger.error(f"Difficulty assessment failed: {str(e)}")
                
        return difficulty
    
    # Payload generation methods
    def _generate_sql_payloads(self) -> List[Dict[str, Any]]:
        """Generate SQL injection payloads"""
        payloads = [
            {
                'name': 'Union-based injection',
                'payload': "' UNION SELECT 1,user(),database(),version()-- -",
                'description': 'Extract database information',
                'risk_level': 'High',
                'success_probability': 80
            },
            {
                'name': 'Boolean-based blind',
                'payload': "' AND (SELECT COUNT(*) FROM information_schema.tables)>0-- -",
                'description': 'Test for blind SQL injection',
                'risk_level': 'Medium',
                'success_probability': 70
            }
        ]
        return payloads
    
    def _generate_xss_payloads(self) -> List[Dict[str, Any]]:
        """Generate XSS payloads"""
        payloads = [
            {
                'name': 'Basic script injection',
                'payload': '<script>alert("XSS")</script>',
                'description': 'Basic XSS test payload',
                'risk_level': 'Medium',
                'success_probability': 85
            },
            {
                'name': 'Event handler injection',
                'payload': '<img src=x onerror=alert("XSS")>',
                'description': 'Image event handler XSS',
                'risk_level': 'Medium',
                'success_probability': 80
            }
        ]
        return payloads
    
    def _generate_command_payloads(self) -> List[Dict[str, Any]]:
        """Generate command injection payloads"""
        payloads = [
            {
                'name': 'Basic command execution',
                'payload': '; cat /etc/passwd',
                'description': 'Unix system file access',
                'risk_level': 'High',
                'success_probability': 90
            },
            {
                'name': 'Windows command execution',
                'payload': '& type C:\\Windows\\System32\\drivers\\etc\\hosts',
                'description': 'Windows system file access',
                'risk_level': 'High',
                'success_probability': 85
            }
        ]
        return payloads
    
    def _generate_auth_bypass_payloads(self) -> List[Dict[str, Any]]:
        """Generate authentication bypass payloads"""
        payloads = [
            {
                'name': 'SQL injection bypass',
                'payload': "admin' OR '1'='1'-- -",
                'description': 'SQL injection authentication bypass',
                'risk_level': 'High',
                'success_probability': 80
            },
            {
                'name': 'NoSQL injection bypass',
                'payload': '{"$ne": null}',
                'description': 'NoSQL injection bypass',
                'risk_level': 'Medium',
                'success_probability': 70
            }
        ]
        return payloads
    
    # Helper methods
    def _suggest_exploitation_tools(self, vuln_type: str) -> List[str]:
        """Suggest tools for exploiting specific vulnerability types"""
        tool_map = {
            'sql_injection': ['sqlmap', 'Burp Suite', 'OWASP ZAP'],
            'xss': ['XSSer', 'Burp Suite', 'BeEF'],
            'command_injection': ['Burp Suite', 'OWASP ZAP', 'Custom scripts'],
            'auth_bypass': ['Burp Suite', 'Hydra', 'Custom scripts'],
            'ftp_anonymous_access': ['FTP client', 'FileZilla', 'wget']
        }
        return tool_map.get(vuln_type, ['Manual testing', 'Burp Suite'])
    
    def _detect_challenge_type(self, packet_data_list: List[Dict]) -> str:
        """Detect the type of CTF challenge based on traffic patterns"""
        protocols = [packet.get('protocol', '') for packet in packet_data_list]
        
        if 'HTTP' in protocols or 'HTTPS' in protocols:
            return 'web'
        elif 'FTP' in protocols or 'SSH' in protocols:
            return 'network'
        elif any('crypt' in str(packet.get('data', '')).lower() for packet in packet_data_list):
            return 'crypto'
        else:
            return 'forensics'
    
    def _identify_technology_stack(self, packet_data_list: List[Dict]) -> List[str]:
        """Identify technologies used in the challenge"""
        technologies = set()
        
        for packet in packet_data_list:
            data = str(packet.get('data', '')).lower()
            
            if 'apache' in data:
                technologies.add('Apache')
            if 'nginx' in data:
                technologies.add('Nginx')
            if 'php' in data:
                technologies.add('PHP')
            if 'mysql' in data:
                technologies.add('MySQL')
                
        return list(technologies)
    
    def _detect_security_measures(self, packet_data_list: List[Dict]) -> List[str]:
        """Detect security measures in place"""
        measures = set()
        
        for packet in packet_data_list:
            data = str(packet.get('data', '')).lower()
            
            if 'csrf' in data:
                measures.add('CSRF Protection')
            if 'jwt' in data:
                measures.add('JWT Authentication')
            if 'ssl' in data or 'tls' in data:
                measures.add('SSL/TLS Encryption')
                
        return list(measures)
    
    def _calculate_context_adjustments(self, vulnerabilities: List[Dict], challenge_type: str, security_measures: List[str]) -> Dict[str, int]:
        """Calculate confidence score adjustments based on context"""
        adjustments = {}
        
        # Adjust based on challenge type
        if challenge_type == 'web':
            adjustments['web_context'] = +10
        elif challenge_type == 'crypto':
            adjustments['crypto_context'] = +15
            
        # Adjust based on security measures
        security_penalty = len(security_measures) * -5
        adjustments['security_measures'] = security_penalty
        
        return adjustments
    
    def _load_vulnerability_patterns(self) -> Dict[str, Any]:
        """Load vulnerability detection patterns"""
        return {
            'sql_injection': {
                'patterns': ["'", 'UNION', 'SELECT', '--'],
                'confidence_base': 85
            },
            'xss': {
                'patterns': ['<script>', 'javascript:', 'onerror='],
                'confidence_base': 80
            }
        }
    
    def _load_payload_templates(self) -> Dict[str, List[str]]:
        """Load payload templates for different vulnerability types"""
        return {
            'sql': ["' OR 1=1--", "' UNION SELECT NULL--"],
            'xss': ['<script>alert(1)</script>', '<img src=x onerror=alert(1)>'],
            'cmd': ['; ls -la', '&& whoami', '| cat /etc/passwd']
        }
    
    def _detect_sql_injection(self, data: str, packet_index: int) -> List[Dict[str, Any]]:
        """Detect SQL injection vulnerabilities"""
        vulnerabilities = []
        
        try:
            sql_patterns = [
                r"'\s*(OR|AND)\s+['\"]?1['\"]?\s*=\s*['\"]?1",
                r"UNION\s+SELECT",
                r";\s*DROP\s+TABLE",
                r"'\s*;\s*--",
                r"admin['\"]?\s*--"
            ]
            
            for pattern in sql_patterns:
                matches = re.finditer(pattern, data, re.IGNORECASE)
                for match in matches:
                    vulnerabilities.append({
                        'type': 'sql_injection',
                        'severity': 'HIGH',
                        'confidence': 90,
                        'description': 'SQL injection vulnerability detected',
                        'evidence': match.group(),
                        'location': f'Packet {packet_index}, position {match.start()}',
                        'exploitation_difficulty': 'Medium',
                        'potential_impact': 'Data extraction, authentication bypass'
                    })
                    
        except Exception:
            pass
            
        return vulnerabilities
    
    def _detect_xss(self, data: str, packet_index: int) -> List[Dict[str, Any]]:
        """Detect Cross-Site Scripting vulnerabilities"""
        vulnerabilities = []
        
        try:
            xss_patterns = [
                r'<script[^>]*>.*?</script>',
                r'javascript:',
                r'on\w+\s*=\s*["\'].*?["\']',
                r'<iframe[^>]*>',
                r'alert\s*\('
            ]
            
            for pattern in xss_patterns:
                matches = re.finditer(pattern, data, re.IGNORECASE)
                for match in matches:
                    vulnerabilities.append({
                        'type': 'xss',
                        'severity': 'MEDIUM',
                        'confidence': 85,
                        'description': 'Cross-Site Scripting vulnerability detected',
                        'evidence': match.group(),
                        'location': f'Packet {packet_index}, position {match.start()}',
                        'exploitation_difficulty': 'Easy',
                        'potential_impact': 'Session hijacking, credential theft'
                    })
                    
        except Exception:
            pass
            
        return vulnerabilities
    
    def _detect_command_injection(self, data: str, packet_index: int) -> List[Dict[str, Any]]:
        """Detect command injection vulnerabilities"""
        vulnerabilities = []
        
        try:
            cmd_patterns = [
                r';\s*(ls|dir|cat|type|whoami|id|pwd)',
                r'\|\s*(nc|netcat|bash|sh|cmd)',
                r'`.*?`',
                r'\$\(.*?\)',
                r'&&\s*(rm|del|format)'
            ]
            
            for pattern in cmd_patterns:
                matches = re.finditer(pattern, data, re.IGNORECASE)
                for match in matches:
                    vulnerabilities.append({
                        'type': 'command_injection',
                        'severity': 'HIGH',
                        'confidence': 88,
                        'description': 'Command injection vulnerability detected',
                        'evidence': match.group(),
                        'location': f'Packet {packet_index}, position {match.start()}',
                        'exploitation_difficulty': 'Medium',
                        'potential_impact': 'Remote code execution, system compromise'
                    })
                    
        except Exception:
            pass
            
        return vulnerabilities
    
    def _detect_auth_bypass(self, data: str, packet_index: int) -> List[Dict[str, Any]]:
        """Detect authentication bypass attempts"""
        vulnerabilities = []
        
        try:
            auth_patterns = [
                r'admin["\']?\s*:\s*["\']?admin',
                r'username\s*=\s*["\']?admin["\']?.*password\s*=\s*["\']?["\']?',
                r'login\s*=\s*["\']?1["\']?',
                r'auth\s*=\s*["\']?true["\']?'
            ]
            
            for pattern in auth_patterns:
                matches = re.finditer(pattern, data, re.IGNORECASE)
                for match in matches:
                    vulnerabilities.append({
                        'type': 'auth_bypass',
                        'severity': 'HIGH',
                        'confidence': 75,
                        'description': 'Authentication bypass attempt detected',
                        'evidence': match.group(),
                        'location': f'Packet {packet_index}, position {match.start()}',
                        'exploitation_difficulty': 'Medium',
                        'potential_impact': 'Unauthorized access, privilege escalation'
                    })
                    
        except Exception:
            pass
            
        return vulnerabilities
    
    def _scan_network_vulnerabilities(self, packet_data_list: List[Dict]) -> List[Dict[str, Any]]:
        """Scan for network protocol vulnerabilities"""
        vulnerabilities = []
        
        try:
            for i, packet_data in enumerate(packet_data_list):
                protocol = packet_data.get('protocol', '').upper()
                data = packet_data.get('data', '')
                
                if protocol == 'FTP' and 'anonymous' in data.lower():
                    vulnerabilities.append({
                        'type': 'ftp_anonymous_access',
                        'severity': 'MEDIUM',
                        'confidence': 85,
                        'description': 'Anonymous FTP access detected',
                        'evidence': 'Anonymous login attempt found',
                        'location': f'Packet {i}',
                        'exploitation_difficulty': 'Easy',
                        'potential_impact': 'Information disclosure, file access'
                    })
                    
                if protocol == 'SMTP' and ('vrfy' in data.lower() or 'expn' in data.lower()):
                    vulnerabilities.append({
                        'type': 'smtp_user_enumeration',
                        'severity': 'LOW',
                        'confidence': 75,
                        'description': 'SMTP user enumeration possible',
                        'evidence': 'VRFY/EXPN commands detected',
                        'location': f'Packet {i}',
                        'exploitation_difficulty': 'Easy',
                        'potential_impact': 'User enumeration, information gathering'
                    })
                    
        except Exception as e:
            if self.logger:
                self.logger.error(f"Network vulnerability scanning failed: {str(e)}")
                
        return vulnerabilities